# Java 多线程
## 应用程序、进程与线程
* 应用程序：
* 进程：
	* 运行时（running是一个正在执行中的程序。
	* 进程间内存不是共享的（独占）。
	* 进程间通信使用Socket（套接字）。
* 线程：
	* 进程内并发执行的代码段。
	* 线程之间共享内存。
	* 创建灵活响应的桌面程序。
	* 每个运行着的线程对应一个stack。
	* 是进程中一个独立的控制单元，线程控制着程序的执行。一个进程中至少有一个线程。
* JVM 启动时会有一个进程java.exe。该进程中至少有一个线程负责java程序的执行，而且这个线程运行的代码存在于main中，该线程称为主线程。JVM中有一个负责垃圾回收的副线程、负责程序计数的副线程等其它线程，统称为守护线程。
## 创建线程的方式
1. 继承Thread类
	1. 定义一个类，继承Thread类。
	2. 重写Thread类中`run()`方法。
	3. 调用线程的start方法。（启动线程，虚拟机调用`run()`方法。）
2. 实现Runnable接口
	1. 定义类实现Runnable接口。
	2. 实现Runnable接口中的run方法，将要线程执行的代码存放在该`run()`方法中。
	3. 通过Thread类建立线程对象。做法是将实现Runnable接口的子类对象作为参数传递给Thread类的构造函数。（因为自定义的`run()`方法所属的对象是Runnable接口的子类对象，所以要让线程去指定对象的`run()`方法，就必须明确该run()方法的所属对象）
	4. 调用Thread类的start方法去开启线程并调用Runnable接口类的`run()`方法。
3. 也可使用匿名内部类
	1. ````java
		new Thread( new Runnable(){
			public void run(){}
		}).start();
	   ````
	2. ````java
		new Thread(){
			public void run(){}
		}.start();
	   ````
4. 使用实现方式的优点：避免了单继承的局限性。
5. 推荐在定义线程时使用实现方式。
## 线程的状态
![](http://i.imgur.com/4Un0cFl.png)
* 程序执行过程中，多个线程都得获取cpu的执行权。某一时刻只能有一个线程在执行（多核除外），cpu在不同的进程中做着快速切换。多线程的一个特性：随机性
* `static Thread currentThread()`：获取当前线程对象。
* `getName()`:获取线程名称
* `setName()`:设置线程名称
## 多线程安全问题
### 问题描述
* 当多条语句在操作共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行，导致共享数据的错误。
### 解决办法
* 对操作共享数据的非原子操作，进行同步。某个时间，只允许一个线程操作，在执行过程中其它线程不可以参与执行。加锁，变并行为串行，
### 同步实现方式
1. ````java
	synchronized(this){
		//需要被同步的代码
	}
   ````
2. ````java
	 public synchronized void function(){}
   ````
3. 使用synchronized修饰的函数称为同步函数，与同步代码块功能相同，但同步代码块使用的是自定义对象，而同步函数使用的是this。
4. `public static void funaction(){}`，静态同步方法使用该类的字节码对象作为锁。静态进内存时没有本类对象，但是一定有该类的字节码对象。类名.class，类型是Class。
5. 对于多个生产者和消费者问题，应定义while判断标记：
	* 让被唤醒的线程再一次判断标记
### 同步分析
1. 同步的前提：
	* 必须有两个或两个以上的线程。
	* 必须是多个线程使用同一个锁。
	* 必须保证在同步中只能有一个线程在运行。
2. 同步的优缺点：
	* 优点：解决了线程安全问题
	* 缺点：多个线程需要判断锁，较为消耗资源。
### 判断多线程程序是否存在问题:
1. 明确哪些代码是多线程运行代码。
2. 明确共享数据
3. 明确多线程运行代码中哪些语句是是操作操作共享数据的。
## 死锁
1. 一般发生在同步的嵌套中。两个线程分别各自拥有对方所需要的锁，便发生死锁现象。
2. 如在生产者和消费者问题中，所有线程都位于等待队列。两个消费者在消费条件不满足的情况下，进入等待队列。生产者生产足够后，在`wait()`之前唤醒一个消费者，消费者消费完成后，`notify()`一个线程，便进入等待队列。第二个消费者判断消费条件不足，直接进入等待队列等待。至此，三个线程都已进入等待队列等待。
3. 解决方法：
	1. 使用notifyAll()代替notify()。
	2. 使用等待固定时间值，如wait(20);
## 进程间通信
1. wait()：当前线程进入等待队列；失去CPU的抢占权；失去对象锁定权；等待别人通知或一段时间
2. sleep()：释放CPU执行权，不释放锁。
3. notify()：唤醒线程等待队列里的等待线程。
3. join()：等待某个线程执行完成后再继续执行。
4. setPriority(int num)：设置优先级，1，5，10。
5. yield()：瞬时放弃CPU执行权，谦逊
6. 在线程T1中调用T2.join()时，T1等待T2执行完成后再继续执行。
7. Thread.setDaemon(true);设置一个线程为守护线程（守护线程为其它线程提供服务，若进程中的线程都是守护线程的话，则进程终止了。）
5. 结束线程方法：让`run()`方法结束，也就是线程结束。强制结束线程方法：`interrupt()`方法。
## 线程升级
* JDK1.5中提供了线程升级的解决方案，将同步synchronized替换成显式的Lock操作。将Object中wait,notify,notifyAll替换成Condition对象（可以使用Lock的方法获得）。一个Lock对象可以对应多个Condition对象，可以互相唤醒对方线程。
## 避免使用同步的方式
1. CAS：compare and set：比较和设置。