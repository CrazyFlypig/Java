# Java开发建议
## 1. 避免对变长参数的重载。
* 若重载函数和原函数都符合函数调用规范，则会产生调用二异性。
* 编译器对重载方法的编译机制是从最简单的开始“猜想”，符合编译条件即可通过。即调用不含变成参数的函数（不用封装成数组对象）。
* 对开发者不友好，代码可读性下降
## 2. 别让null值和空值威胁到变长方法。
````java
methodA(String str, Integer... is);
methodB(String str, String... str);
client.methodA("china")
client.methodA("china",null)
````
* 程序有错，编译不通过。
* 对于变参为null的调用，编译器无法区分methodA和methodB导致不能正常调用
* 修改方法：让编译器知晓null的类型。
````java
String[] strs = null;
client.methodB("china",strs);
````
## 3. 覆写变长方法也要循规蹈矩。
* 覆写必须满足的条件：
	1. 重写方法不能缩小访问权限。
	2. **参数列表必须与被重写方法相同。**（参数列表包括参数数量、参数类型、参数顺序）
	3. 返回类型必须与被重写方法的相同或是其子类。
	4. 重写方法不能抛出新异常，或超出父类异常范围，但可以抛出更少，更有限的异常，或者不抛出异常。
## 4. 警惕自增陷阱
`count = count++;`
* 在C/C++中，上述语句等价于`count++`。
* 而在java中，不论上述代码执行多少次，count的值始终是初值。
* Java中原子操作包括：
	1. 除long和double之外的基本类型的赋值操作
	2. 所有引用reference的赋值操作 
	3. java.concurrent.Atomic.*包中所有类的一切操作。
* `count++`执行过程：
	1. 读取主存中的count值，赋值给一个局部变量tmp
	2. tmp+1
	3. 将tmp赋值给count。
* `count = count++`执行过程：
	1. 读取`count++`中count值，赋值给一个局部成员变量tmp。
	2. 执行count+1。
	3. 返回临时变量tmp的值。
* 修改：使用`count++`;
## 5. 慎用静态导入
* 对于静态导入，遵循两个原则：
	1. 不使用`*`通配符，除非是导入静态常量类（只包含常量的类和接口）
	2. 方法名具有明确清晰表象意义的工具类。
## 6. 不要在本类中覆盖静态导入的变量和方法。
* 由编译器的**最短路径原则**：如果能在本类中查找到的变量、常量、方法，就不会到其它包、父类或接口中查找，以确保本类中的属性、方法优先。
## 7. 显式声明UID。
* 在进行序列化和反序列时，如果类不一致，反序列化时就会抛出一个`InvalidClassException`异常。原因是序列化和反序列化对应类版本发生了变化，JVM不能把数据流转换成实例对象。
* JVM根据SerialVersionUID，也叫流标识符（Stream Unique Identifier）。其声明方式包括显式声明和隐式声明两种：
	* 显式声明：`private static final long serivalVersionUID = XXXXL;`
	* 隐式声明：编译器依据类、包、方法、属性、参数、返回值等诸多因子计算唯一值。
* 如需要反序列化向上兼容，即新类可以通过旧类的序列化流反序列化，需要自声明UID，“欺骗”JVM。