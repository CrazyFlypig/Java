# Java内存模型与线程
## 1.概述
* 并发的原因：
	1. 计算机的运算速度与它的存储和通信子系统速度差距太大，大量时间都花费在磁盘I/O、网络通信或数据访问上。避免了处理器在大部分时间里都等待其他资源的状态。
	2. 一个服务端对多个客户端提供服务是一个并发应用场景。
## 2. 硬件的效率与一致性
* 基于高速缓存的存储交互很好的解决了处理器与内存的速度矛盾。
## 3. Java内存模型
### 3.1 主内存和工作内存
* Java所有的变量（实例字段，静态字段和构成数组对象的元素）都存储在主内存中。每条线程有自己独有的工作内存，保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程也无法直接访问对方工作内存中的变量，线程间的传递，均需通过主内存来完成。线程、主内存、工作内存三者的关系如图：
* 从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据
部分，而工作内存则对应于虚拟机栈中的部分区域。
### 3.2 内存间交互操作
* 对于主内存与工作内存之间的交互协议，Java内存模型定义了以下8种操作来完成。每种操作都具有原子性，不可再分。
1. lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
2. unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
3. read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后load动作使用。
4. load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
5. use（使用）：作用于工作内存的变量，它把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
6. assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
7. store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后write使用。
8. write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量值放入到主内存的变量中。
* 将一个变量从主内存复制到工作内存，就要顺序地执行read和load操作；将一个变量从工作内存同步回主内存，就要顺序执行store和write操作。Java内存模型要求上述操作必须按顺序执行，而非必须连续执行。不允许复制或同步中某一操作单独出现。
* 不允许一个线程丢弃它最近assign操作，即变量在工作内存中发生变化后就必须把该变量同步回主内存。
* 不允许一个线程无原因地（没有发生任何assign操作）就把数据从线程的工作内存同步回主内存中。
* 一个新的变量只能在主内存中产生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。
* 一个变量在同一时刻只允许一个线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次lock操作后，只有执行相同次数的unlock操作，变量才会被解锁。
* 对一个变量执行lock操作，那将清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作，初始化变量值。
* 如果一个变量之前未被lock锁定，就不允许对其执行unlock操作，也不允许一个线程去unlock另一个线程锁住的变量。
* 对一个变量执行ublock操作前，必须先把这个变量同步回主内存中。
### 3.3 对于volatile型变量的特殊规则
* 关键字volatile是java虚拟机提供的最轻量级的同步机制。
* 被volatile关键字修饰的变量具有两种特性：
	1. 保证此变量对所有线程的可见性。
		* 可见性意味着，当一个线程修改了这个变量的值，新值对其他线程来说是可以立即得知的。新值能立即同步到主内存，以及每次使用前立即从主内存刷新。
		* 而普通变量的值在线程间传递均需要主内存来完成。
	2. 由于volatile变量只能保证可见性，在不符合以下两种运算场景中，我们仍要通过加锁来保证原子性。
		1. 运算结果并不依赖变量的当前值，或者能够确保只有单一线程修改变量的值。
		2. 变量不需要与其他的状态变量共同参与不变约束。
		3. 以下代码适合使用volatile变量控制并发，当shutdown()方法被调用时，能够保证所有线程中执行的doWork()方法立即停下来。
		````java
			volatile boolean shutdownRequested;
			public static void shutdown(){
				shutdownRequested = true;
			}
			public void doWork(){
				while(!shutdownRequested){
					//do stuff
				}
			}
		````
	3. 使用volatile变量的第二个语义是禁止指令重排序优化（机器级优化操作）。
		* 指令重排序是指CPU采用了将许多条指令不按程序规定的顺序分开发送给各相应电路单元处理。但并不是说指令的任意重排，CPU需要正确处理指令依赖情况以保障程序能得到正确的执行结果。
		* 普通的变量仅仅保证在该方法的执行过程中所有依赖赋值结果的地方都能取到正确的结果，而不保证变量赋值操作的顺序与代码中的执行顺序一致。
		* Volatile修饰的变量，如果有两个或多个CPU访问同一块内存，且其中一个在观测另一个，就需要内存屏障来保证一致性。
* Volatile的性能：
	1. Volatile变量的读操作的性能消耗与普通变量无异，但写操作慢一点，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。
	2. 大多数情况下volatile的总开销低于锁，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足场景的需求。
### 3.4 对于long和double型变量的特殊规则
* 允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进
行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的
原子性，这点就是所谓的long和double的非原子性协定。
* 目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，
因此我们在编写代码时一般不需要把用到的long和double变量专门声明为volatile。
### 3.5 原子性、可见性和有序性
* 原子性（Atomicity）：基本数据类型的访问读写是具备原子性。在synchronized块
之间的操作也具备原子性。
* 可见性（Visibility）：可见性是指当一个线程修改了共享变量的值，其他线程能够立即
得知这个修改。
	* volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。
	* 同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）”这条规则获得的。
	* 被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看见final字段的值。
	````java
		public static final int i;
		public final int j;
		static{
			i = 0;
		}
		{
			//也可在构造函数中初始化
			j = 0;
		}
	````
* 有序性：如果在本线程内观察，所有的操作都是有
序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表
现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。
	* volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。
### 3.6 先行发生原则
* 判断数据是否存在竞争、线程是否安全的主要依据。
* “天然的”先行发生关系：
	1. 程序次序规则（Program Order Rule）：在一个线程内，按照控制流顺序，进行先后操作。
	2. 管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。
	3. volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。
	4. 线程启动规则（Thread Start Rule）：Thread对象的start（）方法先行发生于此线程的每一个动作。
	5. 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。
	6. 线程中断规则（Thread Interruption Rule）：对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted（）方法检测到是否有中断发生。
	7. 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize（）方法的开始。
	8. 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。
## 4 Java与线程
### 4.1 线程的实现
* 线程可以把一个进程的资源分配和执行调度分开，各个线程可以共享资源，又可以独立调度。
* 每个已经执行`start()`且还未结束的java.lang.Thread类的实例就代表一个线程。
* Thread类的关键方法都声明为Native的，使用平台手段实现。
* 实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。
#### 1.使用内核线程实现
* 内核线程（Kernel-Level Thread,KLT）：由操作系统内核支持的线程。
* 程序一般不直接使用内核线程，而是使用内核线程的一种高级接口————轻量级进程（Light Weight Process,LWP），轻量级进程就是我们通常意义上的线程。每个轻量级进程都由一个内核线程支持。
* 轻量级进程基于内核线程实现，各种操作需要系统调用实现，代价较高，需要在用户态和内核态来回切换。由于每个轻量级进程都由一个内核线程支持，需要消耗一定的内核资源，因此轻量级进程数量有限。
#### 2.使用用户线程实现
* 用户线程是指完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。
* 对于程序得当的用户线程，不需要切换到内核态，操作是快速并高效的。
* 用户线程由于没有内核的支援，所有线程操作都需要用户程序自己处理，程序比较复杂。
#### 3.使用用户线程加轻量级进程混合实现
* 在混合实现下，既存在用户线程，也存在轻量级进程。用户线程的创建、切换、析构等操作依然廉价，而操作系统提供支持的轻量级进程则作为用户线程和内
核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。
### 4.2 Java线程调度
* 线程调度：系统为线程分配处理器使用权的过程，主要分为协同式线程调度和抢占式线程调度。
* 协同式线程调度：程序执行时间由线程本身来控制，线程结束后主动通知系统切换至另一线程。优点：实现简单，切换操作可见，基本不存在线程同步问题。缺点：线程执行时间不可控制，一个线程出现问题会导致整个程序阻塞。
* 抢占式线程调度：每个线程由系统来分配执行时间，线程切换不由线程本身决定。优点：线程执行时间是系统可控的，不存在一个进程导致整个程序阻塞的问题。
* Java使用的线程调度方式是抢占式线程调度。存在十个级别的线程优先级，优先级越高越容易被系统选择执行。优先级并不可靠，线程的最终调度还是取决于操作系统。
### 4.3 状态转换
* 在任意时间，一个线程只能有且只有一个状态。
1. 新建（New）：创建后尚未启动的线程处于这种状态。
2. 运行（Runnable）：线程有可能正在执行，也有可能正在等着CPU为它分配执行时间。包括操作系统状态中的Running和Ready。
3. -1 无限期等待（Waiting）：处于无限期等待状态的线程不会被分配CPU的执行时间，它们要等待被其它线程显式的唤醒。以下操作会让线程进入无限期等待状态：
    1. 没有设置Timeout参数的Object.wait()方法，Thread.join()方法。
    2. LockSupport.park()方法。
3. -2 限期等待（Time Waiting）：处于限期等待状态的线程不会被分配CPU的执行时间，不过无需等待其它线程显式唤醒，在一定时间后由系统主动唤醒。
    1. Thread.sleep()方法。
    2. 设置了Timeout参数的Object.wait()方法和Thread.join()方法。
    3. LockSupport.parkNanos()方法。
    4. LockSupport.parkUntil()方法。
4. 阻塞（Blocked）：线程被阻塞。阻塞与等待的区别：“阻塞状态 ”在等待着获取到一个排他锁，这个事件将在另一个线程放弃这个锁的时候发生；而“等待
状态”则是在等待一段时间，或者唤醒动作发生。在程序等待进入同步区域的时候，线程将进入这种状态。
5. 结束（Terminated）：已终止线程的线程状态，线程已经结束执行。
![](https://i.imgur.com/3BQmoWx.png)